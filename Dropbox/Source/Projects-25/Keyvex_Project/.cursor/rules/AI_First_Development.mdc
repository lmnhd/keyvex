---
description: 
globs: 
alwaysApply: true
---
# AI First Development Philosophy

## Core Principle: Trust AI Intelligence

Modern Language Models are **super intelligent** and can make nuanced decisions on their own. Stop overengineering their inputs and outputs with rigid programmatic constraints.

## ❌ AVOID: Old-School AI Constraints

**DON'T** write code like this:
```typescript
// BAD: Overengineered regex constraints
const hasExplicitCreateRequest = /\b(create|build|make|generate)\b.*\b(tool|calculator|assessment)\b/i.test(userInput);
if (hasExplicitCreateRequest) {
  // Force specific behavior
}

// BAD: Rigid pattern matching
const TRIGGERS = {
  'create': 'IMMEDIATE_ACTION',
  'build': 'IMMEDIATE_ACTION'
};
```

**WHY IT'S BAD:**
- Assumes the AI can't understand natural language nuance
- Creates brittle logic that breaks with slight variations
- Prevents the model from using contextual reasoning
- Leads to robotic, unnatural interactions

## ✅ EMBRACE: AI-First Approach

**DO** write prompts like this:
```typescript
// GOOD: Natural, intelligent prompting
const prompt = `
You're helping users create tools. 

RULES:
1. If the user wants to CREATE something, do it
2. If you've asked 3 questions, create the tool
3. Use your judgment - you're smart enough to know what they want

Context: User said "${userInput}"
Previous answers: ${answersCount}

Be helpful and natural.
`;
```

**WHY IT'S BETTER:**
- Trusts the AI's natural language understanding
- Allows for contextual reasoning and edge cases
- Creates more natural, human-like interactions
- Reduces complex code maintenance

## Development Guidelines

### 1. **Prompt Design**
- Write conversational, human-like instructions
- Give context, not rigid rules
- Trust the model to interpret intent correctly
- Use examples when helpful, not exhaustive pattern lists

### 2. **Logic Flow**
- Let AI models make branching decisions
- Avoid complex if/else chains based on text parsing
- Use AI reasoning instead of programmatic text analysis
- Allow for natural conversation flow

### 3. **Error Handling**
- Don't try to catch every possible user input variation
- Let the model handle unexpected inputs gracefully
- Focus on core functionality, not edge case protection
- Trust intelligent fallback responses

### 4. **Integration Patterns**
```typescript
// GOOD: Simple, AI-driven flow
const response = await aiModel.generateResponse({
  userInput,
  context: previousAnswers,
  instruction: "Help them build what they need"
});

// BAD: Over-constrained flow  
if (triggerPatterns.create.test(input)) {
  if (sufficientData.check(answers)) {
    return forceCreation();
  } else {
    return askMoreQuestions();
  }
}
```

## When to Use Traditional Logic

**Still use programmatic logic for:**
- Data validation and security
- API calls and integrations  
- Database operations
- Performance-critical paths
- Type safety and error boundaries

**DON'T use programmatic logic for:**
- Understanding user intent
- Conversation flow decisions
- Content generation choices
- Natural language interpretation

## Implementation Examples

### API Endpoint Design
```typescript
// AI-First API Handler
export async function POST(request: Request) {
  const { userInput, context } = await request.json();
  
  // Let AI decide what to do
  const aiResponse = await aiModel.process({
    input: userInput,
    context,
    instruction: "Analyze what the user needs and respond appropriately"
  });
  
  return Response.json(aiResponse);
}
```

### Prompt Engineering
```typescript
// AI-First Prompt
const createPrompt = (userInput: string, context: any) => `
You're an intelligent assistant helping users create business tools.

Context: ${JSON.stringify(context)}
User Request: "${userInput}"

Use your intelligence to:
- Understand what they really want
- Ask good follow-up questions if needed
- Create tools when it makes sense
- Be natural and helpful

Trust your judgment.
`;
```

## Remember: AI Models Are Smart

- They understand context and nuance
- They can handle ambiguity and variations  
- They make better decisions than rigid regex patterns
- They create more natural user experiences
- They reduce code complexity and maintenance

**Let them think for themselves!**

