// Dedicated Tool Creation Agent - Handles ONLY tool generation with proper validation

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { generateObject } from 'ai';
import { openai } from '@ai-sdk/openai';
import { anthropic } from '@ai-sdk/anthropic';
import { getPrimaryModel, getFallbackModel, getProcessConfig, getProviders } from '@/lib/ai/models/model-config';
import { ProductToolDefinition } from '@/lib/types/product-tool';
import logger from '@/lib/logger';

import { LogicArchitectAgent } from '@/lib/ai/agents/logic-architect';
import { processToolCreation } from './core-logic';
import { requireAuth } from '@/lib/auth/debug';
import { getBehaviorTracker } from '@/lib/ai/behavior-tracker';

// Simple color scheme detection (inline replacement)
const DEFAULT_COLOR_SCHEMES = {
  professional: {
    primary: '#3b82f6',
    secondary: '#6b7280',
    background: '#ffffff',
    surface: '#f9fafb',
    text: { primary: '#111827', secondary: '#6b7280', muted: '#9ca3af' },
    border: '#e5e7eb',
    success: '#10b981',
    warning: '#f59e0b',
    error: '#ef4444'
  }
} as const;

type ColorSchemeKey = keyof typeof DEFAULT_COLOR_SCHEMES;

const detectColorScheme = (context: any): ColorSchemeKey => 'professional';

// Input schema for tool creation requests
const toolCreationRequestSchema = z.object({
  userIntent: z.string(),
  context: z.object({
    targetAudience: z.string().optional(),
    industry: z.string().optional(),
    toolType: z.string().optional(),
    features: z.array(z.string()).optional(),
    businessDescription: z.string().optional(),
    colors: z.array(z.string()).optional(),
    collectedAnswers: z.record(z.string()).optional(),
    brandAnalysis: z.object({
      colors: z.array(z.any()).optional(),
      style: z.string().optional(),
      personality: z.array(z.string()).optional(),
      recommendations: z.array(z.string()).optional()
    }).optional(),
    conversationHistory: z.array(z.any()).optional(),
    selectedWorkflow: z.array(z.any()).optional(),
    uploadedFiles: z.array(z.object({
      name: z.string(),
      type: z.string(),
      size: z.number(),
      hasLogo: z.boolean().optional(),
      description: z.string()
    })).optional(),
    brainstormingResult: z.any().optional(),
    logicArchitectInsights: z.object({
      coreWConcept: z.string().optional(),
      keyCalculations: z.array(z.any()).optional(),
      interactionFlow: z.array(z.any()).optional(),
      valueProposition: z.string().optional(),
      creativeEnhancements: z.array(z.string()).optional(),
      userExperienceFlow: z.array(z.any()).optional(),
      businessLogic: z.array(z.any()).optional()
    }).nullable().optional()
  }).optional(),
  selectedModel: z.string().optional(),
  existingTool: z.any().optional(),
  updateType: z.enum(['color', 'title', 'description', 'features', 'components', 'general']).optional()
});

// ProductToolDefinition schema for structured output
const productToolDefinitionSchema = z.object({
  id: z.string(),
  slug: z.string(),
  version: z.string(),
  status: z.enum(['draft', 'published', 'archived']),
  createdAt: z.number(),
  updatedAt: z.number(),
  createdBy: z.string(),
  
  metadata: z.object({
    id: z.string(),
    slug: z.string(),
    title: z.string(),
    description: z.string(),
    shortDescription: z.string(),
    type: z.string(),
    category: z.string(),
    targetAudience: z.string(),
    industry: z.string(),
    tags: z.array(z.string()),
    estimatedCompletionTime: z.number(),
    difficultyLevel: z.enum(['beginner', 'intermediate', 'advanced']),
    features: z.array(z.string()),
    icon: z.object({
      type: z.enum(['lucide', 'emoji']),
      value: z.string()
    })
  }),
  
  // React component code as string
  componentCode: z.string(),
  
  // Style information - STRICT: initialStyleMap is now REQUIRED
  initialStyleMap: z.record(z.string()), // Generated by AI - REQUIRED for dynamic styling
  currentStyleMap: z.record(z.string()).optional(),  // Active, editable style map

  // Simplified color scheme
  colorScheme: z.object({
    primary: z.string(),
    secondary: z.string(),
    background: z.string(),
    surface: z.string(),
    text: z.object({
      primary: z.string(),
      secondary: z.string(),
      muted: z.string()
    }),
    border: z.string(),
    success: z.string(),
    warning: z.string(),
    error: z.string()
  }),
  
  // Simple analytics
  analytics: z.object({
    enabled: z.boolean(),
    completions: z.number(),
    averageTime: z.number()
  }).optional()
});

// Helper function to create model instance
function createModelInstance(provider: string, modelId: string) {
  switch (provider) {
    case 'openai':
      return openai(modelId);
    case 'anthropic':
      return anthropic(modelId);
    default:
      return openai('gpt-4o');
  }
}

// POST handler - Tool Creation Agent
export async function POST(request: NextRequest) {
  const requestStartTime = Date.now();
  logger.info({ endpoint: '/api/ai/create-tool', method: 'POST' }, 'ðŸ”§ API [create-tool]: Request received');
  
  try {
    const userId = await requireAuth();
    logger.info({ userId }, 'ðŸ”§ API [create-tool]: User authenticated successfully');
    
    const body = await request.json();
    logger.debug({ 
      bodyKeys: Object.keys(body || {}),
      userIntent: body.userIntent,
      contextKeys: Object.keys(body.context || {}),
      selectedModel: body.selectedModel,
      hasExistingTool: !!body.existingTool,
      updateType: body.updateType
    }, 'ðŸ”§ API [create-tool]: Request body parsed and analyzed');
    
    logger.debug({ 
      hasBrainstormingResult: !!body.context?.brainstormingResult,
      hasLogicArchitectInsights: !!body.context?.logicArchitectInsights,
      brainstormingKeys: body.context?.brainstormingResult ? Object.keys(body.context.brainstormingResult) : [],
      logicArchitectKeys: body.context?.logicArchitectInsights ? Object.keys(body.context.logicArchitectInsights) : []
    }, 'ðŸ”§ API [create-tool]: AI context analysis');
    
    const validatedData = toolCreationRequestSchema.parse(body);
    logger.info({ 
      userIntentLength: validatedData.userIntent.length,
      contextKeys: Object.keys(validatedData.context || {}),
      selectedModel: validatedData.selectedModel,
      validationSuccess: true 
    }, 'ðŸ”§ API [create-tool]: Schema validation passed');

    const { userIntent, context, existingTool } = validatedData;

    // Track the creation request
    const tracker = getBehaviorTracker();
    const startTime = Date.now();

    logger.info({ 
      hasTracker: !!tracker,
      coreLogicCall: 'processToolCreation' 
    }, 'ðŸ”§ API [create-tool]: Calling core logic processor');
    
    const toolCreationResult = await processToolCreation(
      userIntent,
      {
        ...context,
        selectedModel: validatedData.selectedModel // Pass selectedModel through context
      },
      existingTool,
      userId
    );

    logger.info({ 
      success: true,
      toolId: toolCreationResult?.tool?.id,
      toolSlug: toolCreationResult?.tool?.slug,
      toolTitle: toolCreationResult?.tool?.metadata?.title,
      isValid: toolCreationResult?.validation?.isValid,
      issuesCount: toolCreationResult?.validation?.issues?.length || 0,
      blockersCount: toolCreationResult?.validation?.blockers?.length || 0,
      processingTimeMs: Date.now() - startTime
    }, 'ðŸ”§ API [create-tool]: Core logic processing completed');
    
    // Check for undefined values in the returned tool
    if (toolCreationResult?.tool) {
      const undefinedFields = [];
      if (!toolCreationResult.tool.id || toolCreationResult.tool.id.includes('undefined')) {
        undefinedFields.push('id: ' + toolCreationResult.tool.id);
      }
      if (!toolCreationResult.tool.slug || toolCreationResult.tool.slug.includes('undefined')) {
        undefinedFields.push('slug: ' + toolCreationResult.tool.slug);
      }
      if (!toolCreationResult.tool.metadata?.id || toolCreationResult.tool.metadata.id.includes('undefined')) {
        undefinedFields.push('metadata.id: ' + toolCreationResult.tool.metadata?.id);
      }
      if (!toolCreationResult.tool.metadata?.slug || toolCreationResult.tool.metadata.slug.includes('undefined')) {
        undefinedFields.push('metadata.slug: ' + toolCreationResult.tool.metadata?.slug);
      }
      
      if (undefinedFields.length > 0) {
        logger.warn({ undefinedFields, toolId: toolCreationResult.tool.id }, 'ðŸ”§ API [create-tool]: Undefined values detected in response');
      } else {
        logger.debug({ toolId: toolCreationResult.tool.id }, 'ðŸ”§ API [create-tool]: Response validation passed - no undefined values');
      }
    }

    // Track successful creation
    if (tracker && toolCreationResult?.tool) {
      logger.debug({ trackerId: 'behavior-tracker', toolId: toolCreationResult.tool.id }, 'ðŸ”§ API [create-tool]: Recording behavior tracking data');
      
      tracker.trackToolGeneration({
        toolDefinitionId: toolCreationResult.tool.id,
        toolName: toolCreationResult.tool.metadata.title,
        toolType: toolCreationResult.tool.metadata.type,
        context: {
          ...context,
          userContext: {
            selectedModel: validatedData?.selectedModel || 'default',
            hasExternalBrainstorming: !!(context?.brainstormingResult || context?.logicArchitectInsights),
            toolComplexity: context?.toolType || 'unknown'
          }
        },
        success: true,
        duration: Date.now() - startTime,
        validationResults: [{
          ...toolCreationResult.validation,
          // Add metadata for Final Polish stage
          attempt: 1, // TODO: Track attempt number for retries
          sessionPhase: 'initial_creation' // Could be: initial_creation, iteration, final_polish
        }]
      });

      logger.info({ 
        behaviorTracked: true,
        toolId: toolCreationResult.tool.id,
        toolName: toolCreationResult.tool.metadata.title 
      }, 'ðŸ”§ API [create-tool]: Behavior tracking completed');
    }

    const totalRequestTime = Date.now() - requestStartTime;
    logger.info({ 
      success: true,
      toolTitle: toolCreationResult?.tool?.metadata?.title || 'Unknown',
      totalRequestTimeMs: totalRequestTime,
      validationSuccess: toolCreationResult?.validation?.isValid || false
    }, 'ðŸ”§ API [create-tool]: Request completed successfully');

    return NextResponse.json({
      success: true,
      tool: toolCreationResult?.tool,
      validation: toolCreationResult?.validation,
      message: `Created ${toolCreationResult?.tool?.metadata?.title || 'tool'} successfully`
    });

  } catch (error) {
    const totalRequestTime = Date.now() - requestStartTime;
    logger.error({ 
      error: error instanceof Error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : String(error),
      totalRequestTimeMs: totalRequestTime,
      endpoint: '/api/ai/create-tool'
    }, 'ðŸ”§ API [create-tool]: Request failed with error');
    
    // Track failed creation
    const tracker = getBehaviorTracker();
    if (tracker) {
      logger.debug({ trackerId: 'behavior-tracker', errorType: error instanceof Error ? error.name : 'UnknownError' }, 'ðŸ”§ API [create-tool]: Recording failure in behavior tracking');
      
      tracker.trackToolGeneration({
        toolDefinitionId: 'creation-failed',
        toolName: 'unknown',
        toolType: 'unknown',
        context: {},
        success: false,
        error: error instanceof Error ? error.message : String(error),
        validationResults: []
      });
    }

    return NextResponse.json(
      { 
        success: false, 
        message: error instanceof Error ? error.message : 'Unknown error occurred',
        error: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  logger.info({ endpoint: '/api/ai/create-tool', method: 'GET' }, 'ðŸ”§ API [create-tool]: GET request received');
  
  try {
    // Get the primary model for toolCreator process
    const primaryModel = getPrimaryModel('toolCreator');
    const fallbackModel = getFallbackModel('toolCreator');
    
    const agentInfo = {
      success: true,
      agent: 'Tool Creation Specialist',
      defaultModel: {
        primary: primaryModel ? {
          id: primaryModel.modelInfo.id,
          name: primaryModel.modelInfo.name,
          provider: primaryModel.provider
        } : null,
        fallback: fallbackModel ? {
          id: fallbackModel.modelInfo.id,
          name: fallbackModel.modelInfo.name,
          provider: fallbackModel.provider
        } : null
      },
      capabilities: [
        'Generate new ProductToolDefinitions',
        'Update existing tools',
        'Validate tool schemas',
        'Handle complex business logic',
        'Create professional styling'
      ],
      supportedToolTypes: [
        'ROI Calculator',
        'Assessment Tool', 
        'Pricing Calculator',
        'Lead Qualifier',
        'Survey Builder',
        'Cost Analyzer',
        'Investment Calculator'
      ],
      updateTypes: [
        'color',
        'title', 
        'description',
        'features',
        'components',
        'general'
      ]
    };

    logger.info({ 
      agentInfo: {
        capabilities: agentInfo.capabilities.length,
        supportedToolTypes: agentInfo.supportedToolTypes.length,
        updateTypes: agentInfo.updateTypes.length,
        defaultPrimaryModel: agentInfo.defaultModel.primary?.id
      }
    }, 'ðŸ”§ API [create-tool]: Agent info retrieved successfully');

    return NextResponse.json(agentInfo);

  } catch (error) {
    logger.error({ 
      error: error instanceof Error ? {
        name: error.name,
        message: error.message
      } : String(error),
      endpoint: '/api/ai/create-tool',
      method: 'GET'
    }, 'ðŸ”§ API [create-tool]: GET request failed');

    return NextResponse.json(
      { success: false, error: 'Failed to get agent info' },
      { status: 500 }
    );
  }
} 